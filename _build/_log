### Starting build.
# Target: sage.ml.depends, tags: { package(llvm), extension:ml, file:sage.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sage.ml > sage.ml.depends
# Target: ast.ml.depends, tags: { package(llvm), extension:ml, file:ast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules ast.ml > ast.ml.depends
# Target: irgen.ml.depends, tags: { package(llvm), extension:ml, file:irgen.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules irgen.ml > irgen.ml.depends
# Target: ast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:ast.cmo, file:ast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
+ ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
File "ast.ml", lines 79-84, characters 24-18:
79 | ........................function
80 |     String -> "str"
81 |   | Int -> "int"
82 |   (* | Float -> "float" *)
83 |   | Bool -> "bool"
84 |   | Void -> "void"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
# Target: sast.ml.depends, tags: { package(llvm), extension:ml, file:sast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sast.ml > sast.ml.depends
# Target: sast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:sast.cmo, file:sast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
+ ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
File "sast.ml", lines 41-55, characters 34-5:
41 | ..................................(match e with
42 |     SId(s) -> s
43 |   | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
44 |   | SBinop(e1, op, e2) ->
45 |     string_of_sexpr e1 ^ " " ^ string_of_op op ^ " " ^ string_of_sexpr e2
...
52 |     f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
53 |   | SNoexpr -> ""
54 |   | SCast(t, e) -> string_of_typ t ^ "(" ^ string_of_sexpr e ^ ")" 
55 |     )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
# Target: parser.mly, tags: { package(llvm), extension:mly, file:parser.mly, infer, ocaml, ocamlyacc, parser, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamlyacc parser.mly
# Target: parser.mli.depends, tags: { package(llvm), extension:mli, file:parser.mli, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules parser.mli > parser.mli.depends
# Target: scanner.mll, tags: { package(llvm), extension:mll, file:scanner.mll, lexer, ocaml, ocamllex, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamllex.opt -q scanner.mll
# Target: scanner.ml.depends, tags: { package(llvm), extension:ml, file:scanner.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules scanner.ml > scanner.ml.depends
# Target: parser.cmi, tags: { package(llvm), byte, compile, extension:mli, file:parser.mli, interf, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o parser.cmi parser.mli
# Target: semant.ml.depends, tags: { package(llvm), extension:ml, file:semant.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules semant.ml > semant.ml.depends
# Target: irgen.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:irgen.cmo, file:irgen.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
+ ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
File "irgen.ml", lines 26-30, characters 21-22:
26 | .....................function
27 |       A.Int -> i32_t
28 |     | A.Bool  -> i1_t
29 |     | A.String -> string_t
30 |     | A.Void -> void_t
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
File "irgen.ml", lines 58-89, characters 51-71:
58 | ...................................................match e with
59 |         SIntLit i -> L.const_int (ltype_of_typ t) i
60 |       | SBoolLit b  -> L.const_int (ltype_of_typ t) (if b then 1 else 0)
61 |       | SStringLit s -> 
62 |         (*define_global + const_stringz returns a global constant char array (with null term) in the module 
...
86 |       (*makes sure that only operations and initalization can happen to global constants*)
87 |       | SId(_)
88 |       | SAssign(_,_)
89 |       | SCall(_,_) -> raise (Failure "non-constant global initializer")
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SArray _|SCast (_, _))
File "irgen.ml", lines 144-151, characters 6-93:
144 | ......match e with
145 |         (_, SBoolLit true) -> (A.Int, SIntLit 1)
146 |       | (_, SBoolLit false) -> (A.Int, SIntLit 0)
147 |       | (_, SStringLit s) -> 
148 |         try (A.Int, SIntLit (int_of_string s)) 
149 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
150 |       (* | (typ, SId s) -> to_string map (typ, (snd (lookup map s))) *)
151 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an int"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SIntLit _|SCall (_, _)|
SArray _|SCast (_, _)))
File "irgen.ml", lines 222-225, characters 8-56:
222 | ........match c_type with
223 |           A.String -> build_expr builder map (to_string e)
224 |         | A.Int    -> build_expr builder map (to_int e)
225 |         | A.Bool   -> build_expr builder map (to_bool e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "irgen.ml", lines 162-225, characters 54-56:
162 | ......................................................match e with
163 |         SIntLit i  -> L.const_int i32_t i
164 |       | SBoolLit b  -> L.const_int i1_t (if b then 1 else 0)
165 |       | SStringLit s -> L.build_global_stringptr s "str" builder
166 |       | SId s       -> L.build_load (lookup map s) s builder
...
222 |         match c_type with
223 |           A.String -> build_expr builder map (to_string e)
224 |         | A.Int    -> build_expr builder map (to_int e)
225 |         | A.Bool   -> build_expr builder map (to_bool e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
File "irgen.ml", line 221, characters 13-15:
221 |         let (ty, _) = e in
                   ^^
Warning 26 [unused-var]: unused variable ty.
# Target: scanner.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:scanner.cmo, file:scanner.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o scanner.cmo scanner.ml
# Target: semant.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:semant.cmo, file:semant.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o semant.cmo semant.ml
+ ocamlfind ocamlc -c -package llvm -o semant.cmo semant.ml
File "semant.ml", lines 145-148, characters 22-54:
145 | ......................match t with
146 |           Int -> (Int, (SCast(t, check_expr e map)))
147 |         | String -> (String, (SCast(t, check_expr e map)))
148 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "semant.ml", lines 89-148, characters 29-54:
 89 | .............................match e with
 90 |         Id var -> (type_of_identifier var map, SId var)
 91 |       | BoolLit l -> (Bool, SBoolLit l) 
 92 |       | StringLit l -> (String, SStringLit l)
 93 |       | IntLit l -> (Int, SIntLit l)
...
145 |       | Cast(t, e) -> match t with
146 |           Int -> (Int, (SCast(t, check_expr e map)))
147 |         | String -> (String, (SCast(t, check_expr e map)))
148 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Unop (_, _)
File "semant.ml", line 144, characters 8-14:
144 |       | Noexpr -> (Void, SNoexpr)
              ^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "semant.ml", lines 168-196, characters 35-22:
168 | ...................................match stmt with
169 |         Expr e -> (SExpr (check_expr e vars), vars)
170 |       | Return e -> let (t,e') = check_expr e vars in
171 |         if t = func.rtyp then (SReturn (t, e'), vars)
172 |         else raise (
...
193 |         in (SBlock(fst (check_stmt_list stmt_list vars bvars)), vars)
194 |       | DecAssn((ty, n), e) -> (SDecAssn((ty, n), check_expr e vars), StringMap.add n ty vars)
195 |       | If(e, st1, st2) -> (SIf(check_bool_expr e vars, fst (check_stmt st1 vars), fst (check_stmt st2
196 |          vars)), vars)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
While (_, _)
File "semant.ml", line 142, characters 15-24:
142 |         in let elements' = List.map check_elements elements 
                     ^^^^^^^^^
Warning 26 [unused-var]: unused variable elements'.
# Target: sage.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:sage.cmo, file:sage.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o sage.cmo sage.ml
# Target: ast.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:ast.cmx, file:ast.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o ast.cmx ast.ml
+ ocamlfind ocamlopt -c -package llvm -o ast.cmx ast.ml
File "ast.ml", lines 79-84, characters 24-18:
79 | ........................function
80 |     String -> "str"
81 |   | Int -> "int"
82 |   (* | Float -> "float" *)
83 |   | Bool -> "bool"
84 |   | Void -> "void"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
# Target: sast.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:sast.cmx, file:sast.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o sast.cmx sast.ml
+ ocamlfind ocamlopt -c -package llvm -o sast.cmx sast.ml
File "sast.ml", lines 41-55, characters 34-5:
41 | ..................................(match e with
42 |     SId(s) -> s
43 |   | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
44 |   | SBinop(e1, op, e2) ->
45 |     string_of_sexpr e1 ^ " " ^ string_of_op op ^ " " ^ string_of_sexpr e2
...
52 |     f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
53 |   | SNoexpr -> ""
54 |   | SCast(t, e) -> string_of_typ t ^ "(" ^ string_of_sexpr e ^ ")" 
55 |     )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
# Target: parser.ml.depends, tags: { package(llvm), extension:ml, file:parser.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules parser.ml > parser.ml.depends
# Target: parser.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:parser.cmx, file:parser.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o parser.cmx parser.ml
# Target: irgen.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:irgen.cmx, file:irgen.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o irgen.cmx irgen.ml
+ ocamlfind ocamlopt -c -package llvm -o irgen.cmx irgen.ml
File "irgen.ml", lines 26-30, characters 21-22:
26 | .....................function
27 |       A.Int -> i32_t
28 |     | A.Bool  -> i1_t
29 |     | A.String -> string_t
30 |     | A.Void -> void_t
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
File "irgen.ml", lines 58-89, characters 51-71:
58 | ...................................................match e with
59 |         SIntLit i -> L.const_int (ltype_of_typ t) i
60 |       | SBoolLit b  -> L.const_int (ltype_of_typ t) (if b then 1 else 0)
61 |       | SStringLit s -> 
62 |         (*define_global + const_stringz returns a global constant char array (with null term) in the module 
...
86 |       (*makes sure that only operations and initalization can happen to global constants*)
87 |       | SId(_)
88 |       | SAssign(_,_)
89 |       | SCall(_,_) -> raise (Failure "non-constant global initializer")
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SArray _|SCast (_, _))
File "irgen.ml", lines 144-151, characters 6-93:
144 | ......match e with
145 |         (_, SBoolLit true) -> (A.Int, SIntLit 1)
146 |       | (_, SBoolLit false) -> (A.Int, SIntLit 0)
147 |       | (_, SStringLit s) -> 
148 |         try (A.Int, SIntLit (int_of_string s)) 
149 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
150 |       (* | (typ, SId s) -> to_string map (typ, (snd (lookup map s))) *)
151 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an int"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SIntLit _|SCall (_, _)|
SArray _|SCast (_, _)))
File "irgen.ml", lines 222-225, characters 8-56:
222 | ........match c_type with
223 |           A.String -> build_expr builder map (to_string e)
224 |         | A.Int    -> build_expr builder map (to_int e)
225 |         | A.Bool   -> build_expr builder map (to_bool e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "irgen.ml", lines 162-225, characters 54-56:
162 | ......................................................match e with
163 |         SIntLit i  -> L.const_int i32_t i
164 |       | SBoolLit b  -> L.const_int i1_t (if b then 1 else 0)
165 |       | SStringLit s -> L.build_global_stringptr s "str" builder
166 |       | SId s       -> L.build_load (lookup map s) s builder
...
222 |         match c_type with
223 |           A.String -> build_expr builder map (to_string e)
224 |         | A.Int    -> build_expr builder map (to_int e)
225 |         | A.Bool   -> build_expr builder map (to_bool e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
File "irgen.ml", line 221, characters 13-15:
221 |         let (ty, _) = e in
                   ^^
Warning 26 [unused-var]: unused variable ty.
# Target: scanner.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:scanner.cmx, file:scanner.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o scanner.cmx scanner.ml
# Target: semant.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:semant.cmx, file:semant.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o semant.cmx semant.ml
+ ocamlfind ocamlopt -c -package llvm -o semant.cmx semant.ml
File "semant.ml", lines 145-148, characters 22-54:
145 | ......................match t with
146 |           Int -> (Int, (SCast(t, check_expr e map)))
147 |         | String -> (String, (SCast(t, check_expr e map)))
148 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "semant.ml", lines 89-148, characters 29-54:
 89 | .............................match e with
 90 |         Id var -> (type_of_identifier var map, SId var)
 91 |       | BoolLit l -> (Bool, SBoolLit l) 
 92 |       | StringLit l -> (String, SStringLit l)
 93 |       | IntLit l -> (Int, SIntLit l)
...
145 |       | Cast(t, e) -> match t with
146 |           Int -> (Int, (SCast(t, check_expr e map)))
147 |         | String -> (String, (SCast(t, check_expr e map)))
148 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Unop (_, _)
File "semant.ml", line 144, characters 8-14:
144 |       | Noexpr -> (Void, SNoexpr)
              ^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "semant.ml", lines 168-196, characters 35-22:
168 | ...................................match stmt with
169 |         Expr e -> (SExpr (check_expr e vars), vars)
170 |       | Return e -> let (t,e') = check_expr e vars in
171 |         if t = func.rtyp then (SReturn (t, e'), vars)
172 |         else raise (
...
193 |         in (SBlock(fst (check_stmt_list stmt_list vars bvars)), vars)
194 |       | DecAssn((ty, n), e) -> (SDecAssn((ty, n), check_expr e vars), StringMap.add n ty vars)
195 |       | If(e, st1, st2) -> (SIf(check_bool_expr e vars, fst (check_stmt st1 vars), fst (check_stmt st2
196 |          vars)), vars)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
While (_, _)
File "semant.ml", line 142, characters 15-24:
142 |         in let elements' = List.map check_elements elements 
                     ^^^^^^^^^
Warning 26 [unused-var]: unused variable elements'.
# Target: sage.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:sage.cmx, file:sage.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o sage.cmx sage.ml
# Target: sage.native, tags: { package(llvm), dont_link_with, extension:native, file:sage.native, link, native, ocaml, program, quiet }
ocamlfind ocamlopt -linkpkg -package llvm ast.cmx sast.cmx irgen.cmx parser.cmx scanner.cmx semant.cmx sage.cmx -o sage.native
# Compilation successful.
