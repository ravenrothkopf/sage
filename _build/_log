### Starting build.
# Target: sage.ml.depends, tags: { package(llvm), extension:ml, file:sage.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sage.ml > sage.ml.depends
# Target: ast.ml.depends, tags: { package(llvm), extension:ml, file:ast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules ast.ml > ast.ml.depends
# Target: irgen.ml.depends, tags: { package(llvm), extension:ml, file:irgen.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules irgen.ml > irgen.ml.depends
# Target: ast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:ast.cmo, file:ast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
+ ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
File "ast.ml", lines 84-89, characters 24-18:
84 | ........................function
85 |     String -> "str"
86 |   | Int -> "int"
87 |   | Float -> "float"
88 |   | Bool -> "bool"
89 |   | Void -> "void"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
# Target: sast.ml.depends, tags: { package(llvm), extension:ml, file:sast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sast.ml > sast.ml.depends
# Target: sast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:sast.cmo, file:sast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
+ ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
File "sast.ml", lines 46-61, characters 34-5:
46 | ..................................(match e with
47 |     SId(s) -> s
48 |   | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
49 |   | SBinop(e1, op, e2) ->
50 |     string_of_sexpr e1 ^ " " ^ string_of_op op ^ " " ^ string_of_sexpr e2
...
58 |     f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
59 |   | SNoexpr -> ""
60 |   | SCast(t, e) -> string_of_typ t ^ "(" ^ string_of_sexpr e ^ ")" 
61 |     )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
# Target: parser.mly, tags: { package(llvm), extension:mly, file:parser.mly, infer, ocaml, ocamlyacc, parser, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamlyacc parser.mly
+ /Users/jennyliu/.opam/4.14.0/bin/ocamlyacc parser.mly
1 shift/reduce conflict.
# Target: parser.mli.depends, tags: { package(llvm), extension:mli, file:parser.mli, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules parser.mli > parser.mli.depends
# Target: scanner.mll, tags: { package(llvm), extension:mll, file:scanner.mll, lexer, ocaml, ocamllex, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamllex.opt -q scanner.mll
# Target: scanner.ml.depends, tags: { package(llvm), extension:ml, file:scanner.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules scanner.ml > scanner.ml.depends
# Target: parser.cmi, tags: { package(llvm), byte, compile, extension:mli, file:parser.mli, interf, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o parser.cmi parser.mli
# Target: semant.ml.depends, tags: { package(llvm), extension:ml, file:semant.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules semant.ml > semant.ml.depends
# Target: irgen.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:irgen.cmo, file:irgen.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
+ ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
File "irgen.ml", lines 62-100, characters 51-71:
 62 | ...................................................match e with
 63 |         SIntLit i -> L.const_int (ltype_of_typ t) i
 64 |       | SBoolLit b  -> L.const_int (ltype_of_typ t) (if b then 1 else 0)
 65 |       | SFloatLit l -> L.const_float (ltype_of_typ t) l
 66 |       | SStringLit s ->  
...
 97 |       (*makes sure that only operations and initalization can happen to global constants*)
 98 |       | SId(_)
 99 |       | SAssign(_,_)
100 |       | SCall(_,_) -> raise (Failure "non-constant global initializer")
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SArray _|SCast (_, _))
File "irgen.ml", lines 157-165, characters 6-93:
157 | ......match e with
158 |         (_, SBoolLit true) -> (A.Int, SIntLit 1)
159 |       | (_, SBoolLit false) -> (A.Int, SIntLit 0)
160 |       | (_, SFloatLit f) -> (A.Int, SIntLit(int_of_float f))
161 |       | (_, SStringLit s) -> 
162 |         try (A.Int, SIntLit (int_of_string s)) 
163 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
164 |       (* | (typ, SId s) -> to_string map (typ, (snd (lookup map s))) *)
165 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an int"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SUnop (_, _)|SIntLit _|
SCall (_, _)|SArray _|SCast (_, _)))
File "irgen.ml", lines 178-183, characters 6-95:
178 | ......match e with
179 |         (_, SIntLit(i)) -> (A.Float, SFloatLit(float_of_int i))
180 |       | (_, SStringLit s) -> 
181 |         try (A.Float, SFloatLit (float_of_string s)) 
182 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
183 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an float"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SUnop (_, _)|SFloatLit _|
SBoolLit _|SCall (_, _)|SArray _|SCast (_, _)))
File "irgen.ml", lines 329-333, characters 8-57:
329 | ........match c_type with
330 |           A.String -> build_expr builder map (to_string e)
331 |         | A.Int    -> build_expr builder map (to_int e)
332 |         | A.Bool   -> build_expr builder map (to_bool e)
333 |         | A.Float  -> build_expr builder map (to_float e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "irgen.ml", lines 186-333, characters 54-57:
186 | ......................................................match e with
187 |         SIntLit i  -> L.const_int i32_t i
188 |       | SBoolLit b  -> L.const_int i1_t (if b then 1 else 0)
189 |       | SFloatLit l -> L.const_float float_t l
190 |       | SStringLit s -> L.build_global_stringptr s "str" builder
...
330 |           A.String -> build_expr builder map (to_string e)
331 |         | A.Int    -> build_expr builder map (to_int e)
332 |         | A.Bool   -> build_expr builder map (to_bool e)
333 |         | A.Float  -> build_expr builder map (to_float e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
File "irgen.ml", line 279, characters 8-43:
279 |       | SBinop ((A.Float,_ ) as e1, op, e2) ->
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "irgen.ml", lines 349-408, characters 42-49:
349 | ..........................................function
350 |         SBlock sl -> 
351 |           (fst (List.fold_left build_stmt (builder, vars) sl), vars)
352 |       | SExpr e -> ignore(build_expr builder vars e); (builder, vars)
353 |       | SDecAssn ((t, n), expr) -> (builder, 
...
405 |         add_terminal (fst (build_stmt ((L.builder_at_end context else_bb), vars) else_stmt)) build_br_merge;
406 | 
407 |         ignore(L.build_cond_br bool_val then_bb else_bb builder);
408 |         (L.builder_at_end context merge_bb, vars)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SRange (_, _, _)
File "irgen.ml", line 328, characters 13-15:
328 |         let (ty, _) = e in
                   ^^
Warning 26 [unused-var]: unused variable ty.
File "irgen.ml", line 378, characters 12-22:
378 |         let first_expr = build_expr for_builder vars expr1 in
                  ^^^^^^^^^^
Warning 26 [unused-var]: unused variable first_expr.
# Target: scanner.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:scanner.cmo, file:scanner.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o scanner.cmo scanner.ml
# Target: semant.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:semant.cmo, file:semant.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o semant.cmo semant.ml
+ ocamlfind ocamlc -c -package llvm -o semant.cmo semant.ml
File "semant.ml", lines 164-168, characters 22-56:
164 | ......................match t with
165 |           Int -> (Int, (SCast(t, check_expr e map)))
166 |         | String -> (String, (SCast(t, check_expr e map)))
167 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
168 |         | Float -> (Float, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "semant.ml", line 163, characters 8-14:
163 |       | Noexpr -> (Void, SNoexpr)
              ^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "semant.ml", lines 188-221, characters 35-22:
188 | ...................................match stmt with
189 |         Expr e -> (SExpr (check_expr e vars), vars)
190 |       | Return e -> let (t,e') = check_expr e vars in
191 |         if t = func.rtyp then (SReturn (t, e'), vars)
192 |         else raise (
...
218 |       (* | For((ty, n), e, stmt) -> (SFor((ty, n), check_expr e vars, fst(check_stmt stmt vars)), StringMap.add n ty vars) *)
219 |       (* | For(e1, e2, st) -> (SFor(check_expr e1 vars, check_expr e2 vars, fst(check_stmt st vars)), vars) *)
220 |       | If(e, st1, st2) -> (SIf(check_bool_expr e vars, fst (check_stmt st1 vars), fst (check_stmt st2
221 |          vars)), vars).
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Range (_, _, _)
File "semant.ml", line 161, characters 15-24:
161 |         in let elements' = List.map check_elements elements 
                     ^^^^^^^^^
Warning 26 [unused-var]: unused variable elements'.
# Target: sage.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:sage.cmo, file:sage.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o sage.cmo sage.ml
# Target: ast.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:ast.cmx, file:ast.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o ast.cmx ast.ml
+ ocamlfind ocamlopt -c -package llvm -o ast.cmx ast.ml
File "ast.ml", lines 84-89, characters 24-18:
84 | ........................function
85 |     String -> "str"
86 |   | Int -> "int"
87 |   | Float -> "float"
88 |   | Bool -> "bool"
89 |   | Void -> "void"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
# Target: sast.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:sast.cmx, file:sast.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o sast.cmx sast.ml
+ ocamlfind ocamlopt -c -package llvm -o sast.cmx sast.ml
File "sast.ml", lines 46-61, characters 34-5:
46 | ..................................(match e with
47 |     SId(s) -> s
48 |   | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
49 |   | SBinop(e1, op, e2) ->
50 |     string_of_sexpr e1 ^ " " ^ string_of_op op ^ " " ^ string_of_sexpr e2
...
58 |     f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
59 |   | SNoexpr -> ""
60 |   | SCast(t, e) -> string_of_typ t ^ "(" ^ string_of_sexpr e ^ ")" 
61 |     )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
# Target: parser.ml.depends, tags: { package(llvm), extension:ml, file:parser.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules parser.ml > parser.ml.depends
# Target: parser.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:parser.cmx, file:parser.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o parser.cmx parser.ml
# Target: irgen.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:irgen.cmx, file:irgen.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o irgen.cmx irgen.ml
+ ocamlfind ocamlopt -c -package llvm -o irgen.cmx irgen.ml
File "irgen.ml", lines 62-100, characters 51-71:
 62 | ...................................................match e with
 63 |         SIntLit i -> L.const_int (ltype_of_typ t) i
 64 |       | SBoolLit b  -> L.const_int (ltype_of_typ t) (if b then 1 else 0)
 65 |       | SFloatLit l -> L.const_float (ltype_of_typ t) l
 66 |       | SStringLit s ->  
...
 97 |       (*makes sure that only operations and initalization can happen to global constants*)
 98 |       | SId(_)
 99 |       | SAssign(_,_)
100 |       | SCall(_,_) -> raise (Failure "non-constant global initializer")
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SArray _|SCast (_, _))
File "irgen.ml", lines 157-165, characters 6-93:
157 | ......match e with
158 |         (_, SBoolLit true) -> (A.Int, SIntLit 1)
159 |       | (_, SBoolLit false) -> (A.Int, SIntLit 0)
160 |       | (_, SFloatLit f) -> (A.Int, SIntLit(int_of_float f))
161 |       | (_, SStringLit s) -> 
162 |         try (A.Int, SIntLit (int_of_string s)) 
163 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
164 |       (* | (typ, SId s) -> to_string map (typ, (snd (lookup map s))) *)
165 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an int"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SUnop (_, _)|SIntLit _|
SCall (_, _)|SArray _|SCast (_, _)))
File "irgen.ml", lines 178-183, characters 6-95:
178 | ......match e with
179 |         (_, SIntLit(i)) -> (A.Float, SFloatLit(float_of_int i))
180 |       | (_, SStringLit s) -> 
181 |         try (A.Float, SFloatLit (float_of_string s)) 
182 |         with Failure _ -> raise (Failure ("string cant be cast to an int"))
183 |       | _ -> raise (Failure ("Failure:" ^ string_of_sexpr e ^ "type cant be cast to an float"))...
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(_,
(SNoexpr|SId _|SAssign (_, _)|SBinop (_, _, _)|SUnop (_, _)|SFloatLit _|
SBoolLit _|SCall (_, _)|SArray _|SCast (_, _)))
File "irgen.ml", lines 329-333, characters 8-57:
329 | ........match c_type with
330 |           A.String -> build_expr builder map (to_string e)
331 |         | A.Int    -> build_expr builder map (to_int e)
332 |         | A.Bool   -> build_expr builder map (to_bool e)
333 |         | A.Float  -> build_expr builder map (to_float e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "irgen.ml", lines 186-333, characters 54-57:
186 | ......................................................match e with
187 |         SIntLit i  -> L.const_int i32_t i
188 |       | SBoolLit b  -> L.const_int i1_t (if b then 1 else 0)
189 |       | SFloatLit l -> L.const_float float_t l
190 |       | SStringLit s -> L.build_global_stringptr s "str" builder
...
330 |           A.String -> build_expr builder map (to_string e)
331 |         | A.Int    -> build_expr builder map (to_int e)
332 |         | A.Bool   -> build_expr builder map (to_bool e)
333 |         | A.Float  -> build_expr builder map (to_float e)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
File "irgen.ml", line 279, characters 8-43:
279 |       | SBinop ((A.Float,_ ) as e1, op, e2) ->
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "irgen.ml", lines 349-408, characters 42-49:
349 | ..........................................function
350 |         SBlock sl -> 
351 |           (fst (List.fold_left build_stmt (builder, vars) sl), vars)
352 |       | SExpr e -> ignore(build_expr builder vars e); (builder, vars)
353 |       | SDecAssn ((t, n), expr) -> (builder, 
...
405 |         add_terminal (fst (build_stmt ((L.builder_at_end context else_bb), vars) else_stmt)) build_br_merge;
406 | 
407 |         ignore(L.build_cond_br bool_val then_bb else_bb builder);
408 |         (L.builder_at_end context merge_bb, vars)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SRange (_, _, _)
File "irgen.ml", line 328, characters 13-15:
328 |         let (ty, _) = e in
                   ^^
Warning 26 [unused-var]: unused variable ty.
File "irgen.ml", line 378, characters 12-22:
378 |         let first_expr = build_expr for_builder vars expr1 in
                  ^^^^^^^^^^
Warning 26 [unused-var]: unused variable first_expr.
# Target: scanner.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:scanner.cmx, file:scanner.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o scanner.cmx scanner.ml
# Target: semant.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:semant.cmx, file:semant.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o semant.cmx semant.ml
+ ocamlfind ocamlopt -c -package llvm -o semant.cmx semant.ml
File "semant.ml", lines 164-168, characters 22-56:
164 | ......................match t with
165 |           Int -> (Int, (SCast(t, check_expr e map)))
166 |         | String -> (String, (SCast(t, check_expr e map)))
167 |         | Bool -> (Bool, (SCast(t, check_expr e map)))
168 |         | Float -> (Float, (SCast(t, check_expr e map)))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Void|ArrayTyp _)
File "semant.ml", line 163, characters 8-14:
163 |       | Noexpr -> (Void, SNoexpr)
              ^^^^^^
Warning 11 [redundant-case]: this match case is unused.
File "semant.ml", lines 188-221, characters 35-22:
188 | ...................................match stmt with
189 |         Expr e -> (SExpr (check_expr e vars), vars)
190 |       | Return e -> let (t,e') = check_expr e vars in
191 |         if t = func.rtyp then (SReturn (t, e'), vars)
192 |         else raise (
...
218 |       (* | For((ty, n), e, stmt) -> (SFor((ty, n), check_expr e vars, fst(check_stmt stmt vars)), StringMap.add n ty vars) *)
219 |       (* | For(e1, e2, st) -> (SFor(check_expr e1 vars, check_expr e2 vars, fst(check_stmt st vars)), vars) *)
220 |       | If(e, st1, st2) -> (SIf(check_bool_expr e vars, fst (check_stmt st1 vars), fst (check_stmt st2
221 |          vars)), vars).
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Range (_, _, _)
File "semant.ml", line 161, characters 15-24:
161 |         in let elements' = List.map check_elements elements 
                     ^^^^^^^^^
Warning 26 [unused-var]: unused variable elements'.
# Target: sage.cmx, tags: { package(llvm), compile, extension:cmx, extension:ml, file:sage.cmx, file:sage.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package llvm -o sage.cmx sage.ml
# Target: sage.native, tags: { package(llvm), dont_link_with, extension:native, file:sage.native, link, native, ocaml, program, quiet }
ocamlfind ocamlopt -linkpkg -package llvm ast.cmx sast.cmx irgen.cmx parser.cmx scanner.cmx semant.cmx sage.cmx -o sage.native
# Compilation successful.
