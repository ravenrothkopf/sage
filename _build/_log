### Starting build.
# Target: sage.ml.depends, tags: { package(llvm), extension:ml, file:sage.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sage.ml > sage.ml.depends
# Target: ast.ml.depends, tags: { package(llvm), extension:ml, file:ast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules ast.ml > ast.ml.depends
# Target: irgen.ml.depends, tags: { package(llvm), extension:ml, file:irgen.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules irgen.ml > irgen.ml.depends
# Target: ast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:ast.cmo, file:ast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
+ ocamlfind ocamlc -c -package llvm -o ast.cmo ast.ml
File "ast.ml", lines 79-84, characters 24-18:
79 | ........................function
80 |     String -> "str"
81 |   | Int -> "int"
82 |   | Float -> "float"
83 |   | Bool -> "bool"
84 |   | Void -> "void"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ArrayTyp _
# Target: sast.ml.depends, tags: { package(llvm), extension:ml, file:sast.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules sast.ml > sast.ml.depends
# Target: sast.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:sast.cmo, file:sast.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
+ ocamlfind ocamlc -c -package llvm -o sast.cmo sast.ml
File "sast.ml", lines 42-57, characters 34-5:
42 | ..................................(match e with
43 |     SId(s) -> s
44 |   | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
45 |   | SBinop(e1, op, e2) ->
46 |     string_of_sexpr e1 ^ " " ^ string_of_op op ^ " " ^ string_of_sexpr e2
...
54 |     f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
55 |   | SNoexpr -> ""
56 |   | SCast(t, e) -> string_of_typ t ^ "(" ^ string_of_sexpr e ^ ")" 
57 |     )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SArray _
# Target: parser.mly, tags: { package(llvm), extension:mly, file:parser.mly, infer, ocaml, ocamlyacc, parser, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamlyacc parser.mly
# Target: parser.mli.depends, tags: { package(llvm), extension:mli, file:parser.mli, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules parser.mli > parser.mli.depends
# Target: scanner.mll, tags: { package(llvm), extension:mll, file:scanner.mll, lexer, ocaml, ocamllex, quiet }
/Users/jennyliu/.opam/4.14.0/bin/ocamllex.opt -q scanner.mll
# Target: scanner.ml.depends, tags: { package(llvm), extension:ml, file:scanner.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules scanner.ml > scanner.ml.depends
# Target: parser.cmi, tags: { package(llvm), byte, compile, extension:mli, file:parser.mli, interf, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o parser.cmi parser.mli
# Target: semant.ml.depends, tags: { package(llvm), extension:ml, file:semant.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package llvm -modules semant.ml > semant.ml.depends
# Target: irgen.cmo, tags: { package(llvm), byte, compile, extension:cmo, extension:ml, file:irgen.cmo, file:irgen.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
+ ocamlfind ocamlc -c -package llvm -o irgen.cmo irgen.ml
File "irgen.ml", line 79, characters 54-64:
79 |             let arr_t = L.named_struct_type context ((str_of_typ ityp) ^ suffix) in
                                                           ^^^^^^^^^^
Error: Unbound value str_of_typ
Command exited with code 2.
# Compilation unsuccessful.
